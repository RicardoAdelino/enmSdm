% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bioticVelocity.r
\name{bioticVelocity}
\alias{bioticVelocity}
\title{Shifts in densities across rasters}
\usage{
bioticVelocity(x, times = NULL, atTimes = NULL, longitude = NULL,
  latitude = NULL, proj4 = NULL, ext = NULL,
  metrics = c("centroid", "nsCentroid", "ewCentroid", "nCentroid",
  "sCentroid", "eCentroid", "wCentroid", "nsQuants", "ewQuants", "mean",
  "quants", "prevalence"), quants = c(0.05, 0.1, 0.5, 0.9, 0.95), ...)
}
\arguments{
\item{x}{Either a \code{RasterStack}, a 3-dimensional array, or list representing colonization histories (a "pops" object). If \code{x} is a RasterStack then each raster is assumed to represent a time slice and the rasters \emph{must} be in an equal-area projection. If \code{x} is an array then each matrix in the third dimension is assumed to represent a map at a particular time slice in an equal-area projection. Note that if this is an array you must also specify the arguments \code{xCoord} and \code{yCoord} \emph{or} \code{proj4} and \code{ext}. Regardless of the class of \code{x}, it is assumed values representing the entity for which to calculate velocities are either \code{NA} or >= 0 (i.e., no negative population size).}

\item{times}{Numeric vector or \code{NULL} (default). This specifies the time period represented by each layer in \code{x}. If \code{x} is a \code{RasterStack} then you need to specify the same number of values as layers in \code{x}. If \code{x} is an array then you need to specify the same number of values as the length of \code{x} in the third dimension. The default is \code{NULL} in which case \code{times} will be assigned values starting at 1 and ending at the total number of rasters/layers in \code{x}.}

\item{atTimes}{Numeric, values of \code{times} across which to calculate biotic velocity. You can use this, for example, to calculate biotic velocities across just the first and last time slices represented by \code{x} or any subset of \code{x}. Note that \code{across} \emph{must} be equal to or a subset of \code{times}. The default is \code{NULL}, in which case biotic velocity is calculated across all time slices (i.e., between period 1 and 2, 2 and 3, 3 and 4, etc.).}

\item{longitude}{Numeric matrix or \code{NULL}. If \code{x} is an array, then this is a two-dimensional matrix whose elements represent the longitude coordinates of the centers of cells of \code{x}. The matrix must have the same number of rows and columns as \code{x}. Note that the coordinates must be from an equal-area projection for results to be valid! Ignored if \code{x} is a \code{RasterStack}.}

\item{latitude}{Numeric matrix or \code{NULL}. If \code{x} is an array, then this is a two-dimensional matrix whose elements represent the latitude coordinates of the centers of cells of \code{x}. The matrix must have the same number of rows and columns as \code{x}. Note that the coordinates must be from an equal-area projection for results to be valid! Ignored if \code{x} is a \code{RasterStack}.}

\item{proj4}{String or object of class \code{CRS}. Coordinate reference system (proj4 string) for the maps represented by \code{x}. Ignored if \code{x} is a \code{RasterStack}. Ignored if \code{x} is a \code{RasterStack}.}

\item{ext}{Object of class \code{\link[raster]{extent}} representing the spatial extent of maps in \code{x}. Ignored if \code{x} is a \code{RasterStack}.}

\item{metrics}{Biotic velocity metrics to calculate (default is to calculate them all). The units for all metrics will be the spatial units of the map (usually meters) divided by the temporal units (same units used for \code{times}--most often years).  All metrics ignore \code{NA}s.
\itemize{
    \item \code{centroid}: Movement of mass-weighted centroid.
 \item \code{nsCentroid} or \code{ewCentroid}: Movement of mass-weighted centroid in the north-south or east-west directions. For north-south cardinality, positive values represent movement northward and negative southward. For east-west cardinality, positive values represent movement eastward and negative westward.
 \item \code{nCentroid}, \code{sCentroid}, \code{eCentroid}, and \code{wCentroid}: Movement of mass-weighted centroid in of the portion of the range that is north, south, east, or west of the starting centroid.
 \item \code{nsQuants} or \code{ewQuants}: Movement of the location of the x-th quantile of mass in the north-south or east-west directions. For example, this could be the movement of the 5th, 50th, and 95th quantiles of population size from south to north. The quantiles can be specified in \code{quants}.
 \item \code{mean}: Mean value across all cells (this is not really a measure of "velocity").
 \item \code{quants}: \emph{X}th quantile values across all cells (this is not really a measure of "velocity"). Quantiles are given by \code{quants}.
 \item \code{prevalence}: Number of cells with values > 0 (this is not really a measure of "velocity").
}}

\item{quants}{Numeric vector indicating the quantiles at which biotic velocity is calculated for the "Quants" metrics. Default is \code{c(0.05, 0.10, 0.5, 0.9, 0.95)}.}

\item{...}{Other arguments (not used).}
}
\value{
A data frame with biotic velocities. Fields are as follows:
\itemize{
	\item \code{timeFrom}: Start time of interval
	\item \code{timeTo}: End time of interval
	\item \code{timeSpan}: Duration of interval
}
Depending on \code{metrics} that are specified, additional fields are as follows:
\itemize{
	\item \code{centroidVelocity}, \code{centroidLong}, \code{centroidLat}: Velocity of abundance-weighted centroid and its longitude and latitude.
	\item \code{nsCentroid}, \code{nsCentroidLat}: Velocity of abundance-weighted centroid in north-south direction and its latitude.
	\item \code{ewCentroid}, \code{ewCentroidLong}: Velocity of abundance-weighted centroid in east-west direction and its longitude.
	\item \code{nCentroid} and \code{nCentroidAbund}, \code{sCentroid} and \code{sCentroidAbund}, \code{eCentroid} and \code{eCentroidAbund}, or \code{wCentroid} and \code{wCentroidAbund}: Velocity of abundance-weighted centroid of all cells with abundance >0 that fall north, south, east, or west of centroid of initial population (population in first time step), plus abundance of all such populations.
	\item \code{nsCentroidVelocity_quantX} and \code{nsCentroidLat_quantX}, or \code{ewCentroidVelocity_quantX} and \code{ewCentroidLat_quantX}: Velocity of the Xth quantile abundance in the north-south or east-west directions, plus the latitude or longitude thereof.
	\item \code{mean}: Mean abundance in "timeTo" time step.
	\item \code{quantile_quantX}: The \emph{X}th quantile(s) of abundance in the "timeTo" time step.
	\item \code{prevalence}: Proportion of non-\code{NA} cells with abundance >0 in the "timeTo" time step.
}
}
\description{
This function calculates several metrics of biotic velocity for a stack of rasters, an array representing a gridded landscape, or a "pops" (list) object.
}
\details{
This function may fail or yield erroneous velocities if the region of interest is near a pole or spans the international date line. It converts rasters to arrays before doing calculations, so using very large rasters may yield slow performance and may not even work, depending on memory requirements.
}
\examples{
# simulate species starting at center of map
# will be using a spatially Gaussian distribution
# that uses only longitude and latitude as predictors
gauss <- function(x1, x2, mu1=0, mu2=0, sigma1=1, sigma2=0, rho=0) {

	first <- ((x1 - mu1) / sigma1)^2
	prod <- ((2 * rho * (x1 - mu1) * (x2 - mu2)) / (sigma1 * sigma2))
	second <- ((x2 - mu2) / sigma2)^2
	denom <- 2 * (1 - rho^2)

	inside <- first - prod + second
	inside <- (-1 * inside) / denom
	
	expo <- exp(inside)
	
	expo
	
}

r <- raster()
r[] <- 1
mollweide <- enmSdm::getCRS('mollweide', TRUE)
r <- raster::projectRaster(r, crs=mollweide)
ll <- enmSdm::longLatRasters(r, m=TRUE)

# simulated population trajectory:
# time 0 to 1: no change
# time 1 to 2: size doubles, no shift
# time 2 to 3: size halves, no shift
# time 3 to 4: size same, moves north
# time 4 to 5: size same, moves south
# time 5 to 6: size same, moves east
# time 6 to 7: size same, moves west
# times 7 to 8: size same, moves northwest
# times 8 to 10: size same, moves northwest, double time
# times 10 to 11: size doubles, moves northwest
# times 11 to 12: same size, moves northwest
x1 <- ll[['longitude']]
x2 <- ll[['latitude']]

s1 <- 2000000
s2 <- 1000000
shift <- 1500000

species_t0 <- gauss(x1=x1, x2=x2, sigma1=s1, sigma2=s2)
species_t1 <- gauss(x1=x1, x2=x2, sigma1=s1, sigma2=s2)
species_t2 <- gauss(x1=x1, x2=x2, sigma1=2 * s1, sigma2=2 * s2)
species_t3 <- gauss(x1=x1, x2=x2, sigma1=s1, sigma2=s2)
species_t4 <- gauss(x1=x1, x2=x2, mu2=shift, sigma1=s1, sigma2=s2)
species_t5 <- gauss(x1=x1, x2=x2, sigma1=s1, sigma2=s2)
species_t6 <- gauss(x1=x1, x2=x2, mu1=shift, sigma1=s1, sigma2=s2)
species_t7 <- gauss(x1=x1, x2=x2, sigma1=s1, sigma2=s2)
species_t8 <- gauss(x1=x1, x2=x2, mu1=-1 * shift, mu2=1 * shift, sigma1=s1, sigma2=s2)
species_t10 <- gauss(x1=x1, x2=x2, mu1=-2 * shift, mu2=2 * shift, sigma1=s1, sigma2=s2)
species_t11 <- gauss(x1=x1, x2=x2, mu1=-3 * shift, mu2=3 * shift, sigma1=2 * s1, sigma2=s2)
species_t12 <- gauss(x1=x1, x2=x2, mu1=-4 * shift, mu2=4 * shift, sigma1=2 * s1, sigma2=s2,
	rho=-0.5)
	
rasts <- raster::stack(species_t0, species_t1, species_t2, species_t3,
	species_t4, species_t5, species_t6, species_t7, species_t8,
	species_t10, species_t11, species_t12)
times <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12)
names(rasts) <- paste0('t', times)
plot(rasts)

# across just start and end time periods
(vels <- bioticVelocity(rasts, times=times, atTimes=c(0, 12),
	metrics='centroid'))

# across each time interval
(vels <- bioticVelocity(rasts, times=times, metrics='centroid'))

# plot movement of centroid
weightedLong <- species_t0 * ll[['longitude']]
weightedLat <- species_t0 * ll[['latitude']]
startLong <- cellStats(weightedLong, 'sum') / cellStats(species_t0, 'sum')
startLat <- cellStats(weightedLat, 'sum') / cellStats(species_t0, 'sum')

plot(species_t0)

for (i in 1:(nrow(vels) - 1)) {

	x1 <- vels$centroidLong[i]
	y1 <- vels$centroidLat[i]
	x2 <- vels$centroidLong[i + 1]
	y2 <- vels$centroidLat[i + 1]
	
	move <- sqrt((x1 - x2)^2 + (y1 - y2)^2)
	if (move > 10) arrows(x1, y1, x2, y2, angle=15, length=0.05)

}

# all metrics
(vels <- bioticVelocity(x=rasts, times=times))
}
